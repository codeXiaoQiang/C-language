#include <stdio.h>

int main()
{
    /*
     * 1.逻辑与 &&
     * 结合性: 左结合性
     * 特点: 逻辑短路, 只要第一个表达式为假, 那么第二个表达式就不会计算
     * 因为规则是: 一假则假
     * 2.逻辑或 ||
     * 结合性: 左结合性
     * 特点: 逻辑短路, 只要第一个表达式为真, 那么第二个表达式就不会计算
     * 3.逻辑 !
     * 结合性: 右结合性
     * 特点: 可以连续飞飞飞飞
     */

    /*
    int a = 10; // 11
    //          1(真)  &&  1(真)
//    int res = (10 > 9) && (++a > 5);
    //          0(假)   &&
    // 原因: 无论第二个表达式的结果是真是假, 整个表达式的结果都是假, 所以再计算第二个表达式没有任何意义, 所以只要第一个表达式为假, 第二个表达式就不会运算
    int res = (10 > 19) && (++a > 5);
    printf("res = %i\n", res); // 1(真)   0(假)
    printf("a = %i\n", a); // 11   10
    */

    /*
    int a = 10; // 11
    //          1(真)  ||
    // 原因: 无论第二个表达式的结果是真是假, 整个表达式的结果都是真, 所以再甲酸第二个表达式没有任何意义, 所以只要第一个表达式为真, 第二个表达式不会运算
//    int res = (10 > 9) || (++a > 5);
    //          0(假)   ||     1(真)
    int res = (10 > 19) || (++a > 5);
    printf("res = %i\n", res); // 1(真) 1(真)
    printf("a = %i\n", a); // 10  11
    */

    /*
    //        (!(!(!(10 > 9))))
    //        (!(!(!1)))
    //        (!(!0))
    //        (!1)
    int res = !!!(10 > 9);
    printf("res = %i\n", res);
    */
    // 注意点:
//    int res = !666;
//    int res = !0;

//    int res = 666 && 888;
    int res = 666 && 0;
     printf("res = %i\n", res); // 0 1
    return 0;
}
